const n=`### 36.flex:1 和 flex: auto 的区别

#### ✅ 一、flex:1 和 flex:auto 的「完整展开写法」

这是所有差异的**根源**，建议直接背下来，所有表现都源于这个展开：

##### 1. flex: 1 的完整展开

\`\`\`
flex: 1 = flex: 1 1 0%;
\`\`\`

- flex-grow: 1 → 有剩余空间时，会**参与瓜分**剩余空间
- flex-shrink: 1 → 空间不足时，会**被等比例压缩**
- flex-basis: 0% → 初始基准宽度为「0」，分配空间时**完全无视自身内容宽度**

##### 2. flex: auto 的完整展开

\`\`\`
flex: auto = flex: 1 1 auto;
\`\`\`

- flex-grow: 1 → 有剩余空间时，**同样会参与瓜分**剩余空间（和 flex:1 一致）
- flex-shrink: 1 → 空间不足时，**同样会被等比例压缩**（和 flex:1 一致）
- flex-basis: auto → 初始基准宽度为「子项自身内容的宽度」，分配空间时**先保留内容宽度，再瓜分剩余空间**

> ⚠️ 补充：很多资料写 \`flex:1 = flex:1 1 0\`，\`0\` 和 \`0%\` 效果**完全等价**，浏览器解析无差异；\`flex:auto\` 没有第二种写法，就是固定的 \`1 1 auto\`。

---

#### ✅ 二、flex:1 和 flex:auto 的「核心区别」（2 个关键，最重点）

两者的 \`flex-grow\` 和 \`flex-shrink\` 完全相同，**所有的差异都来源于 \\*\\***flex-basis\\***\\* 的值不同**，衍生出 2 个核心区别，这是面试高频考点，也是实际开发的坑点：

##### ✨ 区别 1：分配「容器剩余空间」的计算逻辑完全不同

> [!TIP]
> flex 布局分配空间的规则是：**先算「子项基准宽度总和」 → 再算「容器总宽度 - 基准宽度总和 = 剩余空间」 → 最后按 flex-grow 权重瓜分剩余空间**

flex: 1 场景

- 基准宽度是 \`0%\`，意味着「所有 flex:1 的子项，初始宽度都算 0」，**剩余空间 = 容器总宽度 - 0**，也就是「容器的全部宽度」会被所有 flex:1 的子项**按权重均分**。✔ 最终效果：**所有 flex:1 的子项，宽度完全相等**，无论内容多少。

#### flex: auto 场景

- 基准宽度是 \`auto\`（自身内容宽度），意味着「先给每个子项分配足够展示自身内容的宽度」，**剩余空间 = 容器总宽度 - 所有子项的内容宽度总和**，最后再把剩余空间按权重均分。✔ 最终效果：**子项宽度「不相等」**，内容越多的子项，最终宽度越大；内容越少的，最终宽度越小。

##### ✨ 区别 2：是否会被「自身内容」撑开（开发中最常用的判断依据）

这是最直观、最容易感知的区别，也是你大概率会遇到的开发场景：

> [!TIP]

#### ✅ flex: 1 → 「不会被内容撑开」，强制均分宽度

不管子项内部的内容有多长（比如长文本、大图片、固定宽度元素），flex:1 的子项**永远会被强制均分容器的宽度**，内容会自适应子项宽度（换行 / 滚动），**不会因为内容多就变宽**。

#### ✅ flex: auto → 「会被内容撑开」，宽度随内容变化

flex:auto 的子项，宽度「保底是内容的宽度」，如果内容很长，子项宽度会跟着变大，挤压其他子项的空间；如果内容很少，子项宽度就很小，把空间让给其他子项。
`;export{n as default};
