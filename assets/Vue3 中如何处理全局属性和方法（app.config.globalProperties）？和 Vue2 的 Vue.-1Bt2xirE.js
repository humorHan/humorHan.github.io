const e="### Vue3 中如何处理全局属性和方法（app.config.globalProperties）？和 Vue2 的 Vue.prototype 有什么区别？（续）\n\n#### 关键区别详解（续）：\n\n1. **TS 类型支持（续）**：Vue2 扩展 `Vue.prototype` 后，TS 无法自动推导类型，需手动扩展 `Vue` 接口：\n2. ts\n\n```typescript\n// Vue2 + TSimport Vue from 'vue'declare module 'vue/types/vue' {interface Vue {\n    $api: typeof axios\n  }}\nVue.prototype.$api = axios\n```\n\n1. Vue3 扩展 `globalProperties` 时，扩展类型更简洁且精准：\n2. ts\n\n```typescript\n// Vue3 + TSimport type { App } from 'vue'declare module 'vue' {interface ComponentCustomProperties {\n    $api: typeof axios\n    $formatTime: (time: number) => string}}// 类型推导生效，组件中使用 $api 会提示类型\n```\n\n1. **访问方式**：Vue2 中可直接通过 `this.$api` 访问（Options API）；Vue3 的 `<script setup>` 中无 `this`，需通过 `getCurrentInstance()` 获取 app 上下文，或在模板中直接使用。\n2. **优先级**：Vue3 中组件自身的属性 / 方法优先级高于 `globalProperties`，避免全局属性覆盖组件内部逻辑；Vue2 也遵循此规则，但无应用隔离的兜底。\n\n#### 注意事项：\n\n- Vue3 推荐尽量减少全局属性的使用，优先通过 `provide/inject` 或组合式函数（如 `useApi()`）共享逻辑，降低耦合；\n- `getCurrentInstance()` 仅能在 setup 或生命周期钩子中调用，且生产环境下需通过 `instance.appContext` 访问全局属性（开发环境可直接 `instance.proxy`）。";export{e as default};
