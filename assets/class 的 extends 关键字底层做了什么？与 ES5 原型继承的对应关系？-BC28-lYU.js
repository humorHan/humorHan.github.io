const n="### class 的 extends 关键字底层做了什么？与 ES5 原型继承的对应关系？\n\n**答：**\n\n#### （1）extends 底层逻辑\n\n`class Child extends Parent` 是 ES6 语法糖，底层等价于 ES5 的寄生组合式继承，核心步骤：\n\n1. **创建子类构造函数**：`Child` 构造函数内部默认调用 `super()`（父类构造函数），若手动写 `constructor` 则必须先调用 `super`；\n2. **设置原型链**：`Child.prototype.proto = Parent.prototype`（继承父类原型方法）；\n3. **继承静态方法**：`Child.proto = Parent`（父类的静态方法可被子类直接调用）；\n4. **处理 ****super**** 关键字**：`super` 既可以调用父类构造函数，也可以访问父类原型方法（`super.sayName()`）。\n\n#### （2）与 ES5 原型继承的对应关系\n\n#### （3）代码对比\n\njavascript\n\n运行\n\n```javascript\n// ES6 extendsclass Parent {constructor(name) { this.name = name; }sayName() { console.log(this.name); }static staticFn() { console.log('static'); }}class Child extends Parent {constructor(name, age) {super(name); // 等价于 Parent.call(this, name)this.age = age;}}// ES5 等价实现function Parent(name) { this.name = name; }Parent.prototype.sayName = function () { console.log(this.name); };Parent.staticFn = function () { console.log('static'); };function Child(name, age) {Parent.call(this, name); // super(name)this.age = age;}// 继承原型方法Child.prototype = Object.create(Parent.prototype);Child.prototype.constructor = Child;// 继承静态方法Child.__proto__ = Parent;\n```";export{n as default};
