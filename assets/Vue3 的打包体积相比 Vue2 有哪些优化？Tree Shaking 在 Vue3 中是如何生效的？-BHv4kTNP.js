const e="### 22. Vue3 的打包体积相比 Vue2 有哪些优化？Tree Shaking 在 Vue3 中是如何生效的？\n\n**答**：\n\n#### Vue3 打包体积核心优化：\n\n1. **源码模块化重构**：Vue2 的源码是 “整体式” 设计，即使只使用部分功能（如响应式），也会打包整个 Vue 核心；Vue3 将源码拆分为独立的模块（如 `@vue/reactivity`、`@vue/runtime-core`、`@vue/runtime-dom`），仅打包使用的模块，基础体积从 Vue2 的 ～30KB 缩小到 ～10KB（gzip 后）。\n2. **Tree Shaking 友好的 API 设计**：Vue3 的全局 API（如 `ref`、`computed`、`watch`）改为模块化导出，未使用的 API 可被 Tree Shaking 移除；Vue2 的 API 挂载在 `Vue` 构造函数上，无法被 Tree Shaking。\n3. **移除冗余功能**：移除 Vue2 的部分冗余 API（如 `Vue.filter`、`Vue.set`），减少核心体积；同时简化内部逻辑（如虚拟 DOM 优化），进一步缩小体积。\n4. **按需引入内置组件**：Vue3 的内置组件（如 `Teleport`、`Suspense`）仅在使用时才被打包，未使用则不会包含在最终产物中。\n5. **更小的运行时**：Vue3 的运行时（runtime）与编译器（compiler）分离，开发环境使用带编译器的版本，生产环境使用仅运行时的版本（体积更小）；且运行时逻辑优化，体积比 Vue2 运行时更小。\n\n#### Tree Shaking 在 Vue3 中的生效原理：\n\nTree Shaking（摇树优化）是 ESModule 下的特性，通过静态分析代码，移除未被使用的导出（dead code）。Vue3 从以下层面适配 Tree Shaking：\n\n1. **ESModule 模块化**：Vue3 源码全部采用 ESModule 编写（`import/export`），而非 CommonJS（`require/module.exports`），使打包工具（Webpack/Rollup/Vite）能静态分析依赖关系。\n2. **副作用标记**：Vue3 的 package.json 中配置了 `\"sideEffects\": false`，告诉打包工具：Vue3 的模块无副作用（修改全局变量、DOM 等），可安全移除未使用的导出。例：若仅导入 `ref`，打包工具会只保留 `ref` 相关代码，移除 `computed`、`watch` 等未使用的 API。\n3. **模块化的功能拆分**：Vue3 将核心功能拆分为独立的函数 / 模块，如响应式逻辑在 `@vue/reactivity`，虚拟 DOM 在 `@vue/runtime-core`，打包时仅打包使用的模块。\n4. js\n\n```javascript\n// 仅导入 ref，打包体积小import { ref } from 'vue'// 导入所有 API，打包体积大（但未使用的仍会被 Tree Shaking）import { ref, computed, watch } from 'vue'\n```\n\n1. **编译阶段优化**：Vue3 的模板编译器会移除模板中的静态节点、无用指令，进一步减少运行时需要处理的代码。\n\n#### 示例（Vite 打包对比）：\n\n- Vue2 项目（Vue2 + Vue CLI）：生产包体积 ～30KB（gzip）；\n- Vue3 项目（Vue3 + Vite）：生产包体积 ～10KB（gzip），仅为 Vue2 的 1/3。";export{e as default};
