const n='### 19. 前端依赖管理的最佳实践是什么？如何处理依赖冲突、清理无用依赖？\n	**答：**\n	#### 一、依赖管理最佳实践\n	1. **明确依赖类型**：\n		- `dependencies`：运行时依赖（如 vue、axios）；\n		- `devDependencies`：开发时依赖（如 webpack、eslint）；\n		- 避免将开发依赖误放入 `dependencies`，增大产物体积。\n	2. **版本锁定**：\n		- 使用 pnpm/yarn/npm 的锁文件（`pnpm-lock.yaml`/`package-lock.json`），提交到 Git；\n		- 依赖版本号使用精确版本（如 `1.2.3`）或固定主版本（如 `^1.2.3`），避免 `*` 或 `~` 导致版本不一致。\n	3. **定期更新依赖**：\n		- 使用 `pnpm outdated` 查看过期依赖；\n		- 小版本（patch）直接更新，大版本（major/minor）先测试再更新。\n	#### 二、处理依赖冲突\n	1. **定位冲突**：\n		- `pnpm why <package>`：查看依赖被谁引入；\n		- `pnpm ls <package>`：查看依赖的版本树；\n	2. **解决方法**：\n		- **强制统一版本**：在 `package.json` 中添加 `resolutions`（pnpm/yarn 支持）：\n		- json\n		```json\n"resolutions": {"lodash": "^4.17.21" // 强制所有依赖使用该版本}\n````\n\n````\n	- **手动安装指定版本**：`pnpm add lodash@4.17.21`；\n	- **清理缓存重装**：`pnpm store prune && pnpm install`。\n#### 三、清理无用依赖\n1. **检测无用依赖**：\n	- 安装 `depcheck`：`pnpm add -D depcheck`；\n	- 执行 `depcheck`，输出未使用的依赖和缺失的依赖；\n2. **清理步骤**：\n	1. 卸载无用依赖：`pnpm remove <package>`；\n	2. 清理全局缓存：`pnpm store prune`；\n	3. 提交锁文件变更，确保团队依赖一致；\n3. **预防措施**：\n	- 安装依赖时谨慎选择，避免盲目引入；\n	- 定期（每季度）执行 `depcheck` 清理。';export{n as default};
