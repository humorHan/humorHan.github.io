const e="### 24. 如何优化 Webpack/Vite 的构建速度？（如缓存、多线程、按需编译）\n	**答：**\n	#### 一、Webpack 构建速度优化\n	##### 1. 缓存优化（核心）\n	- 开启持久化缓存（`cache.type: 'filesystem'`）；\n	- 开启 loader 缓存（如 `babel-loader?cacheDirectory=true`）；\n	- 使用 `hard-source-webpack-plugin` 生成模块缓存（比内置缓存更彻底）。\n	##### 2. 多线程编译\n	- 安装 `thread-loader`，对耗时 loader 启用多线程：\n\n	```javascript\nmodule: {rules: [{test: /\\.js$/,use: ['thread-loader', // 多线程处理'babel-loader']}]}\n````\n\n````\n- 使用 `swc-loader` 替代 `babel-loader`（Rust 编写，速度提升 10 倍 +）。\n##### 3. 减少编译范围\n- `exclude`/`include` 精准匹配文件：\n\n```javascript\n````\n\nmodule: {rules: [{test: /\\.js$/,include: path.resolve(\\_\\_dirname, 'src'), // 仅编译 src 目录 exclude: /node_modules/, // 排除 node_modulesuse: ['babel-loader']}]}\n\n````\n	- 使用 `externals` 排除第三方库（如 CDN 引入 Vue）：\n\n	```javascript\nexternals: {vue: 'Vue'}\n````\n\n````\n##### 4. 其他优化\n- 升级 Webpack 到最新版本（v5 比 v4 快 20%+）；\n- 禁用不必要的插件（如开发环境禁用压缩插件）；\n- 使用 `webpack-merge` 拆分配置（开发 / 生产分开）。\n#### 二、Vite 构建速度优化\n##### 1. 依赖预构建优化\n- 配置 `optimizeDeps` 精准预构建：\n```javascript\n````\n\n// vite.config.tsexport default defineConfig({optimizeDeps: {include: ['vue', 'axios'], // 强制预构建指定依赖 exclude: ['lodash-es'] // 排除无需预构建的依赖}})\n\n````\n	- 清理预构建缓存：`vite optimize --force`。\n	##### 2. 构建优化\n	- 启用多线程构建：\n	- javascript\n	- 运行\n	```javascript\nbuild: {minify: 'esbuild', // 使用 esbuild 压缩（比 terser 快 20 倍）target: 'es2015',parallel: true // 多线程构建}\n````\n\n````\n- 减少构建产物：关闭 sourcemap（开发环境）、按需引入第三方库。\n##### 3. 其他优化\n- 使用 `@vitejs/plugin-vue-jsx` 替代手动编译 JSX；\n- 开发环境禁用 `host: 0.0.0.0`（仅必要时开启）；\n- 升级 Vite 到最新版本，利用内置性能优化。\n#### 三、通用优化策略\n1. **硬件 / 环境优化**：使用 Node.js 18+、开启磁盘缓存、使用 SSD；\n2. **依赖优化**：使用 pnpm 替代 npm/yarn，减少依赖安装时间；\n3. **按需编译**：开发环境仅编译当前页面的代码（Vite 天然支持，Webpack 需配置 `module.noParse`）；\n4. **监控构建性能**：使用 `speed-measure-webpack-plugin`（Webpack）、`vite-plugin-build-speed`（Vite）定位耗时环节。";export{e as default};
