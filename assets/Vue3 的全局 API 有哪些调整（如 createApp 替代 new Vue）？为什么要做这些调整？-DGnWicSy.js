const e="### 16. Vue3 的全局 API 有哪些调整（如 createApp 替代 new Vue）？为什么要做这些调整？\n\n**答**：\n\n#### 核心全局 API 调整：\n\n#### 调整原因：\n\n1. **实现应用隔离**：Vue2 的全局 API 挂载在 `Vue` 构造函数上，多个应用实例（如 `new Vue({ el: '#app1' })`、`new Vue({ el: '#app2' })`）会共享全局配置（如全局组件、指令），导致冲突；Vue3 的 `createApp` 创建独立的应用实例（app），所有全局配置（组件、指令、全局属性）都挂载在 app 实例上，不同应用实例互不干扰，适配微前端等多应用场景。\n2. **Tree Shaking 友好**：Vue2 的全局 API 是 “全量引入”，即使未使用 `Vue.filter`，也会被打包；Vue3 的 API 改为模块化导出（如 `createApp`、`ref` 等），未使用的 API 可被 Tree Shaking 移除，减小打包体积。\n3. **类型友好**：Vue2 的 `Vue.prototype` 扩展全局属性时，TS 类型推导困难；Vue3 的 `app.config.globalProperties` 可配合 TS 扩展全局类型，更易维护。\n4. **简化响应式 API**：Vue2 的 `Vue.set`/`Vue.delete` 是为了解决 `Object.defineProperty` 的响应式缺陷；Vue3 基于 Proxy，无需这些 API，直接删除 / 添加属性即可保持响应式。\n5. **移除冗余 API**：如 `Vue.filter`，Vue3 推荐用 computed 替代，减少 API 复杂度，同时提升灵活性。\n\n#### 示例：\n\njs\n\n```javascript\n// Vue2import Vue from 'vue'import MyComponent from './MyComponent.vue'Vue.component('MyComponent', MyComponent) // 全局注册，所有应用共享Vue.prototype.$api = axios // 扩展全局属性new Vue({el: '#app',data: { msg: 'Hello' }})// Vue3import { createApp } from 'vue'import MyComponent from './MyComponent.vue'import App from './App.vue'const app = createApp(App)\napp.component('MyComponent', MyComponent) // 仅当前应用可用\napp.config.globalProperties.$api = axios // 仅当前应用可用\n\napp.mount('#app') // 挂载（替代 el）\n```";export{e as default};
