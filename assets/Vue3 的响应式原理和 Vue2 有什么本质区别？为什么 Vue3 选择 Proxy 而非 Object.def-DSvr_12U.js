const e="### 1. Vue3 的响应式原理和 Vue2 有什么本质区别？为什么 Vue3 选择 Proxy 而非 Object.defineProperty？(高频且易错)\n\n**答**：\n\n- **本质区别**：对于引用类型数据来说，Vue2 基于 `Object.defineProperty` 劫持对象的属性，通过遍历对象的每个属性设置 getter/setter 实现响应式；Vue3 基于 ES6 的 `Proxy` 代理整个对象，通过拦截对象的读写、删除、遍历等操作实现响应式。\n- **选择 Proxy 的原因**：\n\n  1. `Object.defineProperty` 只能劫持属性，无法监听数组下标修改、数组长度变化（如 `arr[0] = 1`、`arr.length = 0`），Vue2 需重写数组 7 个方法（push/pop 等）hack 解决；Proxy 能直接监听数组的所有操作。\n  2. `Object.defineProperty` 需遍历对象所有属性，嵌套对象需递归劫持；Proxy 可监听整个对象，嵌套对象访问时才惰性劫持，性能更优。\n  3. Proxy 支持更多拦截操作（如 `deleteProperty`、`has` 等），能覆盖更全面的响应式场景；`Object.defineProperty` 仅支持 `get/set`。\n  4. Proxy 代理的是原对象的 “引用”，无需像 `Object.defineProperty` 那样修改原对象属性；且可直接监听 `Map/Set` 等集合类型，Vue2 无法原生支持。";export{e as default};
